@startuml
skinparam dpi 150
skinparam shadowing false
skinparam DefaultFontName Arial

title C4: Sequence Diagram - Patient Registration (Public) v3\n(With Resilience & Observability)

actor User
participant "PatientRegistrationController" as Controller
participant "PatientRegistrationService" as Service
participant "ExternalServiceClient\n(@CircuitBreaker, @Retry)" as ExternalClient
participant "PatientRepository" as Repo
participant "Auth Service (hap-auth)\n(mTLS + JWT)" as AUTH
participant "RabbitMQ" as MQ
participant "PatientEventHandler" as EventHandler
participant "PatientQueryRepository" as QueryRepo

activate User
autonumber

note over User, QueryRepo
  **Assignment 3 Features:**
  • Resilience: Circuit Breaker, Retry
  • Observability: Zipkin (tracing), Prometheus (metrics), ELK (logs)
  • Correlation ID: End-to-end traceability
end note

User -> Controller : POST /api/v2/patients/register { patient data }
activate Controller

Controller -> Service : registerPatient(dto)\n[Trace ID propagated]
activate Service

Service -> Service : validate consent (dataConsentGiven)
alt Email already exists
  Service -> Repo : existsByEmail(email)
  activate Repo
  Repo --> Service : true
  deactivate Repo
  Service --> Controller : EmailAlreadyExistsException
  deactivate Service
  Controller --> User : 409 Conflict (email in use)
  deactivate Controller
else Email not in use
  activate Service
  Service -> Repo : existsByEmail(email)
  activate Repo
  Repo --> Service : false
  deactivate Repo
  
  ' External call with Circuit Breaker and Retry
  Service -> ExternalClient: registerUser(username=email, password, role=PATIENT)\n[Circuit Breaker + Retry + mTLS]
  activate ExternalClient

  note right of ExternalClient
    Circuit Breaker checks state
    Retry with exponential backoff
    Metrics sent to Prometheus
    Trace sent to Zipkin
  end note

  ExternalClient -> AUTH : POST /api/public/register\n(mTLS + JWT)
  activate AUTH
  alt Auth accepted (201)
    AUTH --> ExternalClient : 201 Created { userId }
    deactivate AUTH
    ExternalClient --> Service : User registered in auth service
  else Auth error (4xx/5xx/timeout)
    AUTH --> ExternalClient : exception
    deactivate AUTH
    ExternalClient --> Service : IllegalArgumentException("Failed to register in Auth")
  end

  deactivate ExternalClient

  alt User registered successfully
    Service -> Repo : save(new Patient ...)
    activate Repo
    Repo --> Service : Patient Entity { patientId }
    deactivate Repo
    
    Service -> MQ : convertAndSend(\n  exchange="hap-exchange",\n  routingKey="patient.registered",\n  event: PatientRegisteredEvent\n)\n[Retry on failure]
    activate MQ

    note right of MQ
      AMQP publishing:
      • Retry on failure
      • Metrics to Prometheus
      • Correlation ID in message
    end note

    MQ --> Service : Event published
    deactivate MQ
    
    Service --> Controller : 201 Created { patientId }
    deactivate Service
    activate Controller
    Controller --> User : 201 Created { patientId }
    deactivate Controller
    
    activate MQ
    MQ -> EventHandler : PatientRegisteredEvent\n{ patientId, fullName, email, phone,\n  address, insuranceInfo, ... }\n[Correlation ID]
    deactivate MQ
    activate EventHandler

    note right of EventHandler
      Handler processing:
      • Extract Correlation ID
      • Trace to Zipkin
      • Metrics to Prometheus
    end note

    EventHandler -> QueryRepo : save(new PatientSummary(...))\n(MongoDB projection)
    activate QueryRepo
    QueryRepo --> EventHandler : OK
    deactivate QueryRepo
    
    deactivate EventHandler
  else Auth registration failed
    activate Service
    Service --> Controller : IllegalArgumentException("Failed to register in Auth")
    deactivate Service
    activate Controller
    Controller --> User : 400 Bad Request { error }
    deactivate Controller
  end
end

@enduml
