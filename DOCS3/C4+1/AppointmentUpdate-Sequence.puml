@startuml AppointmentUpdate-Sequence
skinparam backgroundColor #FFFFFF
skinparam sequenceMessageAlign center
skinparam sequenceArrowThickness 2

title Appointment Update - Sequence Diagram v3\n(With Resilience, Observability & Event Sourcing)

actor Client
participant "AppointmentController\n(@PreAuthorize)" as Controller
participant "AppointmentCommandService\n(@CircuitBreaker, @Retry)" as CommandService
participant "AppointmentService" as Service
participant "ExternalServiceClient\n(@CircuitBreaker, @Retry, @TimeLimiter)" as ExternalClient
participant "AppointmentRepository\n(Write Model - H2)" as WriteRepo
participant "EventStoreService" as EventStoreService
participant "RabbitMQ\nExchange" as RabbitMQ
participant "AppointmentEventHandler" as EventHandler
participant "AppointmentQueryRepository\n(Read Model - MongoDB)" as ReadRepo
participant "AppointmentReminderHandler" as ReminderHandler

autonumber
activate Client

note over Client, ReminderHandler
  **Assignment 3 Features:**
  • Security: JWT (@PreAuthorize), mTLS, RBAC
  • Resilience: Circuit Breaker, Retry, Timeout
  • Observability: Zipkin (tracing), Prometheus (metrics), ELK (logs)
  • Event Sourcing: Immutable event storage
  • Correlation ID: End-to-end traceability
end note

Client -> Controller: PUT /appointments/{id}\n(UpdateAppointmentRequest)\nJWT Token
activate Controller

Controller -> CommandService: updateAppointment(appointmentId, dto)\n[Trace ID propagated]
activate CommandService

CommandService -> Service: updateAppointment(appointmentId, dto)
activate Service

Service -> WriteRepo: findById(appointmentId)
activate WriteRepo
WriteRepo --> Service: Optional<Appointment>
deactivate WriteRepo

Service -> Service: Prepare appointment data

' External call with Circuit Breaker and Retry
Service -> ExternalClient: updateAppointmentInRecords(appointmentId, appointmentData)\n[Circuit Breaker + Retry + mTLS]
activate ExternalClient

note right of ExternalClient
  Circuit Breaker checks state
  Retry with exponential backoff
  Failures ignored (compensation possible)
  Metrics sent to Prometheus
end note

ExternalClient --> Service: Updated (or exception ignored)
deactivate ExternalClient

Service -> Service: Update appointment fields
Service -> WriteRepo: save(appointment)
activate WriteRepo
WriteRepo --> Service: Appointment (updated)
deactivate WriteRepo

Service --> CommandService: Appointment
deactivate Service

' Event Sourcing - Save event to Event Store
CommandService -> EventStoreService: saveEvent(appointmentId,\nEventType.APPOINTMENT_UPDATED,\nappointmentData,\ncorrelationId,\nuserId)
activate EventStoreService

note right of EventStoreService
  Event Sourcing:
  • Calculate version
  • Serialize to JSON
  • Save immutable event
  • Metrics to Prometheus
end note

EventStoreService --> CommandService: EventStore (saved)
deactivate EventStoreService

alt Status is CANCELED
    CommandService -> RabbitMQ: convertAndSend("appointment.canceled", event)\n[Retry + Circuit Breaker]
    activate RabbitMQ
    RabbitMQ --> CommandService: Cancel event published
    deactivate RabbitMQ
else Status is NOT CANCELED
    CommandService -> RabbitMQ: convertAndSend("appointment.updated", event)\n[Retry + Circuit Breaker]
    activate RabbitMQ
    RabbitMQ --> CommandService: Update event published
    deactivate RabbitMQ

    CommandService -> RabbitMQ: convertAndSend("appointment.reminder", event)
    activate RabbitMQ
    RabbitMQ --> CommandService: Reminder event published
    deactivate RabbitMQ
end

CommandService --> Controller: Appointment
deactivate CommandService

Controller --> Client: 200 OK\nAppointment
deactivate Controller
deactivate Client

note right of RabbitMQ
  **Asynchronous processing:**
  Events consumed by handlers
  with correlation ID propagation
end note

alt Event is appointment.updated
    RabbitMQ -> EventHandler: AppointmentUpdatedEvent\n[Correlation ID]
    activate RabbitMQ
    activate EventHandler

    note right of EventHandler
      Handler processing:
      • Extract Correlation ID
      • Trace to Zipkin
      • Metrics to Prometheus
    end note

    EventHandler -> ReadRepo: findById(appointmentId)
    activate ReadRepo
    ReadRepo --> EventHandler: Optional<AppointmentSummary>
    deactivate ReadRepo

    EventHandler -> ReadRepo: save(updated AppointmentSummary)
    activate ReadRepo
    ReadRepo --> EventHandler: Saved
    deactivate ReadRepo
    EventHandler -> EventHandler: Update MongoDB read model
    deactivate EventHandler

    RabbitMQ -> ReminderHandler: AppointmentReminderEvent\n[Correlation ID]
    deactivate RabbitMQ
    activate ReminderHandler
    ReminderHandler -> ReminderHandler: sendReminderEmail(event)
    ReminderHandler -> ReminderHandler: Log reminder details\n[Structured logging to ELK]
    deactivate ReminderHandler
else Event is appointment.canceled
    RabbitMQ -> EventHandler: AppointmentCanceledEvent\n[Correlation ID]
    deactivate RabbitMQ
    activate EventHandler

    EventHandler -> ReadRepo: findById(appointmentId)
    activate ReadRepo
    ReadRepo --> EventHandler: Optional<AppointmentSummary>
    deactivate ReadRepo

    alt Summary exists and status is SCHEDULED or COMPLETED
        EventHandler -> EventHandler: Ignore old cancellation event
    else Summary doesn't exist or status allows cancellation
        EventHandler -> WriteRepo: findById(appointmentId)
        activate WriteRepo
        WriteRepo --> EventHandler: Optional<Appointment>
        deactivate WriteRepo

        alt Appointment found in write model
            EventHandler -> EventHandler: Preserve all appointment fields
            EventHandler -> ReadRepo: save(AppointmentSummary with status CANCELED)
            activate ReadRepo
            ReadRepo --> EventHandler: Saved
            deactivate ReadRepo
        else Appointment not found
            EventHandler -> ReadRepo: save(AppointmentSummary from event)
            activate ReadRepo
            ReadRepo --> EventHandler: Saved
            deactivate ReadRepo
        end
    end
    EventHandler -> EventHandler: Update MongoDB read model
    deactivate EventHandler
end

note right of Controller
  **Este diagrama mostra a atualização de uma consulta**
  com todas as implementações do Assignment 3:
  
  • **Security:** JWT validation, mTLS, RBAC
  • **Resilience:** Circuit Breaker, Retry, Timeout
    (Failures em Records Service são ignorados - compensação possível)
  • **Observability:** Distributed tracing (Zipkin),
    Metrics (Prometheus), Structured logging (ELK)
  • **Event Sourcing:** Immutable event storage
  • **Correlation ID:** End-to-end traceability
end note

@enduml
