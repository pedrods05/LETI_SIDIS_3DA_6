@startuml AppointmentCancel-Sequence
skinparam backgroundColor #FFFFFF
skinparam sequenceMessageAlign center
skinparam sequenceArrowThickness 2

title Appointment Cancel - Sequence Diagram

actor Client
participant "AppointmentController" as Controller
participant "AppointmentCommandService" as CommandService
participant "AppointmentService" as Service
participant "ExternalServiceClient" as ExternalClient
participant "AppointmentRepository\n(Write Model - H2)" as WriteRepo
participant "RabbitMQ\nExchange" as RabbitMQ
participant "AppointmentEventHandler" as EventHandler
participant "AppointmentQueryRepository\n(Read Model - MongoDB)" as ReadRepo

autonumber
activate Client
Client -> Controller: PUT /appointments/{id}/cancel
activate Controller

Controller -> CommandService: cancelAppointment(appointmentId)
activate CommandService

CommandService -> Service: cancelAppointment(appointmentId)
activate Service

Service -> ExternalClient: cancelAppointmentInRecords(appointmentId)
activate ExternalClient
ExternalClient --> Service: Canceled (or exception ignored)
deactivate ExternalClient

Service -> WriteRepo: findById(appointmentId)
activate WriteRepo
WriteRepo --> Service: Optional<Appointment>
deactivate WriteRepo

Service -> Service: Set status = CANCELED
Service -> WriteRepo: save(appointment)
activate WriteRepo
WriteRepo --> Service: Appointment (status = CANCELED)
deactivate WriteRepo

Service --> CommandService: Appointment
deactivate Service

CommandService -> CommandService: publishAppointmentCanceledEvent(appointment)
CommandService -> RabbitMQ: convertAndSend("appointment.canceled", event)
activate RabbitMQ
RabbitMQ --> CommandService: Event published


CommandService --> Controller: Appointment
deactivate CommandService

Controller --> Client: 200 OK\nAppointment (CANCELED)
deactivate Controller
deactivate Client

note right of RabbitMQ
  Asynchronous processing:
  Event is consumed by handler
end note

RabbitMQ -> EventHandler: AppointmentCanceledEvent
deactivate RabbitMQ
activate EventHandler

EventHandler -> ReadRepo: findById(appointmentId)
activate ReadRepo
ReadRepo --> EventHandler: Optional<AppointmentSummary>
deactivate ReadRepo

alt Summary exists and status is SCHEDULED or COMPLETED
    EventHandler -> EventHandler: Ignore old cancellation event
    note right of EventHandler
      Prevents overwriting with
      outdated events
    end note
else Summary doesn't exist or status allows cancellation
    EventHandler -> WriteRepo: findById(appointmentId)
    activate WriteRepo
    WriteRepo --> EventHandler: Optional<Appointment>
    deactivate WriteRepo

    alt Appointment found in write model
        EventHandler -> EventHandler: Preserve all appointment fields
        EventHandler -> ReadRepo: save(AppointmentSummary with status CANCELED)
        activate ReadRepo
        ReadRepo --> EventHandler: Saved
        deactivate ReadRepo
        note right of EventHandler
          Preserves all fields from
          write model, only updates status
        end note
    else Appointment not found
        EventHandler -> ReadRepo: save(AppointmentSummary from event)
        activate ReadRepo
        ReadRepo --> EventHandler: Saved
        deactivate ReadRepo
    end
end

deactivate EventHandler

note right of Controller
  Este diagrama mostra o cancelamento de uma consulta.
  O status é atualizado para CANCELED no write model
  e um evento é publicado no RabbitMQ. O handler
  atualiza o read model (MongoDB) preservando todos
  os campos originais e apenas alterando o status.
end note

@enduml

